"""
Unit tests for file_operations module.
"""

import pytest
import os
import tempfile
import shutil
import subprocess
from pathlib import Path
from unittest.mock import patch, MagicMock

from slurm_gzip.file_operations import find_files_with_suffixes, generate_task_file, execute_gzip_local


class TestFindFilesWithSuffixes:
    """Test the find_files_with_suffixes function."""
    
    def test_find_files_with_suffixes_empty_directory(self, tmp_path):
        """Test finding files in empty directory."""
        files = find_files_with_suffixes(str(tmp_path), {'.txt'})
        assert files == []
    
    def test_find_files_with_suffixes_single_file(self, tmp_path):
        """Test finding single file with specified suffix."""
        # Create test file
        test_file = tmp_path / "test.txt"
        test_file.write_text("test content")
        
        files = find_files_with_suffixes(str(tmp_path), {'.txt'})
        assert len(files) == 1
        assert str(test_file) in files
    
    def test_find_files_with_suffixes_multiple_files(self, tmp_path):
        """Test finding multiple files with specified suffixes."""
        # Create test files
        (tmp_path / "file1.txt").write_text("content1")
        (tmp_path / "file2.log").write_text("content2")
        (tmp_path / "file3.txt").write_text("content3")
        (tmp_path / "file4.py").write_text("content4")
        
        files = find_files_with_suffixes(str(tmp_path), {'.txt', '.log'})
        assert len(files) == 3
        assert any('file1.txt' in f for f in files)
        assert any('file2.log' in f for f in files)
        assert any('file3.txt' in f for f in files)
        assert not any('file4.py' in f for f in files)
    
    def test_find_files_with_suffixes_subdirectories(self, tmp_path):
        """Test finding files in subdirectories."""
        # Create directory structure
        subdir = tmp_path / "subdir"
        subdir.mkdir()
        
        (tmp_path / "file1.txt").write_text("content1")
        (subdir / "file2.txt").write_text("content2")
        (subdir / "file3.log").write_text("content3")
        
        files = find_files_with_suffixes(str(tmp_path), {'.txt'})
        assert len(files) == 2
        assert any('file1.txt' in f for f in files)
        assert any('file2.txt' in f for f in files)
    
    def test_find_files_with_suffixes_no_dot_prefix(self, tmp_path):
        """Test finding files with suffixes that don't start with dot."""
        (tmp_path / "file1.txt").write_text("content1")
        (tmp_path / "file2.log").write_text("content2")
        
        files = find_files_with_suffixes(str(tmp_path), {'txt', 'log'})
        assert len(files) == 2
        assert any('file1.txt' in f for f in files)
        assert any('file2.log' in f for f in files)
    
    def test_find_files_with_suffixes_directory_error(self, tmp_path):
        """Test handling of directory access errors."""
        # Mock os.walk to raise an exception
        with patch('os.walk', side_effect=PermissionError("Access denied")):
            files = find_files_with_suffixes(str(tmp_path), {'.txt'})
            assert files == []
    
    def test_find_files_with_suffixes_sorted_output(self, tmp_path):
        """Test that output files are sorted."""
        (tmp_path / "zebra.txt").write_text("content")
        (tmp_path / "apple.txt").write_text("content")
        (tmp_path / "banana.txt").write_text("content")
        
        files = find_files_with_suffixes(str(tmp_path), {'.txt'})
        assert len(files) == 3
        
        # Check that files are sorted
        file_names = [os.path.basename(f) for f in files]
        assert file_names == ['apple.txt', 'banana.txt', 'zebra.txt']


class TestGenerateTaskFile:
    """Test the generate_task_file function."""
    
    def test_generate_task_file_empty_list(self, tmp_path):
        """Test generating task file with empty file list."""
        output_file = tmp_path / "test.cmds"
        files = []
        
        result = generate_task_file(files, str(output_file))
        assert result == str(output_file.absolute())
        assert output_file.exists()
        
        content = output_file.read_text()
        assert "# Gzip task file generated by slurm_gzip.py" in content
        assert "parallel < gzip.cmds" in content
    
    def test_generate_task_file_single_file(self, tmp_path):
        """Test generating task file with single file."""
        output_file = tmp_path / "test.cmds"
        files = ["/path/to/file.txt"]
        
        result = generate_task_file(files, str(output_file))
        assert result == str(output_file.absolute())
        
        content = output_file.read_text()
        assert "gzip '/path/to/file.txt'" in content
        assert content.count("gzip") == 1
    
    def test_generate_task_file_multiple_files(self, tmp_path):
        """Test generating task file with multiple files."""
        output_file = tmp_path / "test.cmds"
        files = [
            "/path/to/file1.txt",
            "/path/to/file2.log",
            "/path/to/file3.txt"
        ]
        
        result = generate_task_file(files, str(output_file))
        assert result == str(output_file.absolute())
        
        content = output_file.read_text()
        assert "gzip '/path/to/file1.txt'" in content
        assert "gzip '/path/to/file2.log'" in content
        assert "gzip '/path/to/file3.txt'" in content
        assert content.count("gzip") == 3
    
    def test_generate_task_file_skip_compressed(self, tmp_path):
        """Test that already compressed files are skipped."""
        output_file = tmp_path / "test.cmds"
        files = [
            "/path/to/file1.txt",
            "/path/to/file2.gz",  # Already compressed
            "/path/to/file3.log"
        ]
        
        result = generate_task_file(files, str(output_file))
        assert result == str(output_file.absolute())
        
        content = output_file.read_text()
        assert "gzip '/path/to/file1.txt'" in content
        assert "gzip '/path/to/file2.gz'" not in content  # Should be skipped
        assert "gzip '/path/to/file3.log'" in content
        assert content.count("gzip") == 2
    
    def test_generate_task_file_default_output(self, tmp_path):
        """Test generating task file with default output name."""
        # Change to temporary directory
        original_cwd = os.getcwd()
        os.chdir(tmp_path)
        
        try:
            files = ["/path/to/file.txt"]
            result = generate_task_file(files)
            
            # Should create gzip.cmds in current directory
            assert result == str((tmp_path / "gzip.cmds").absolute())
            assert (tmp_path / "gzip.cmds").exists()
        finally:
            os.chdir(original_cwd)
    
    def test_generate_task_file_absolute_path(self, tmp_path):
        """Test that output file path is converted to absolute."""
        output_file = tmp_path / "relative" / "test.cmds"
        files = ["/path/to/file.txt"]
        
        result = generate_task_file(files, str(output_file))
        
        # Result should be absolute path
        assert os.path.isabs(result)
        assert result == str(output_file.absolute())
    
    def test_generate_task_file_content_structure(self, tmp_path):
        """Test the structure of generated task file content."""
        output_file = tmp_path / "test.cmds"
        files = ["/path/to/file.txt"]
        
        generate_task_file(files, str(output_file))
        content = output_file.read_text()
        
        # Check header structure
        lines = content.split('\n')
        assert lines[0] == "# Gzip task file generated by slurm_gzip.py"
        assert lines[1] == "# Each line contains a gzip command to compress a file"
        assert lines[2] == "# Run with: parallel < gzip.cmds"
        assert lines[3] == "# Or use with Slurm: srun --multi-prog gzip.cmds"
        assert lines[4] == ""
        
        # Check command line
        assert lines[5] == "gzip '/path/to/file.txt'"


class TestExecuteGzipLocal:
    """Test the execute_gzip_local function."""
    
    @patch('subprocess.run')
    def test_execute_gzip_local_success(self, mock_subprocess, tmp_path):
        """Test successful local gzip execution."""
        # Create test files
        test_files = [
            str(tmp_path / "file1.txt"),
            str(tmp_path / "file2.log"),
            str(tmp_path / "file3.txt")
        ]
        
        # Mock successful subprocess execution
        mock_subprocess.return_value = MagicMock(returncode=0)
        
        results = execute_gzip_local(test_files, num_threads=2)
        
        assert results['total'] == 3
        assert results['compressed'] == 3
        assert results['skipped'] == 0
        assert results['errors'] == 0
        assert len(results['error_files']) == 0
        
        # Verify subprocess was called for each file
        assert mock_subprocess.call_count == 3
    
    @patch('subprocess.run')
    def test_execute_gzip_local_with_errors(self, mock_subprocess, tmp_path):
        """Test local gzip execution with some errors."""
        test_files = [
            str(tmp_path / "file1.txt"),
            str(tmp_path / "file2.log"),
            str(tmp_path / "file3.txt")
        ]
        
        # Mock mixed results: first success, second error, third success
        def mock_run_side_effect(*args, **kwargs):
            if 'file2.log' in args[0]:
                raise subprocess.CalledProcessError(1, 'gzip', stderr='Permission denied')
            return MagicMock(returncode=0)
        
        mock_subprocess.side_effect = mock_run_side_effect
        
        results = execute_gzip_local(test_files, num_threads=1)
        
        assert results['total'] == 3
        assert results['compressed'] == 2
        assert results['skipped'] == 0
        assert results['errors'] == 1
        assert len(results['error_files']) == 1
        assert 'file2.log' in results['error_files'][0][0]
    
    def test_execute_gzip_local_skip_compressed(self, tmp_path):
        """Test that already compressed files are skipped."""
        test_files = [
            str(tmp_path / "file1.txt"),
            str(tmp_path / "file2.gz"),  # Already compressed
            str(tmp_path / "file3.log")
        ]
        
        with patch('subprocess.run', return_value=MagicMock(returncode=0)):
            results = execute_gzip_local(test_files, num_threads=1)
            
            assert results['total'] == 3
            assert results['compressed'] == 2
            assert results['skipped'] == 1
            assert results['errors'] == 0
    
    def test_execute_gzip_local_auto_threads(self, tmp_path):
        """Test auto-detection of thread count."""
        test_files = [str(tmp_path / "file.txt")]
        
        with patch('subprocess.run', return_value=MagicMock(returncode=0)):
            with patch('multiprocessing.cpu_count', return_value=16):
                results = execute_gzip_local(test_files, num_threads=0)
                
                # Should cap at 8 threads for I/O operations
                assert results['compressed'] == 1
    
    def test_execute_gzip_local_invalid_threads(self, tmp_path):
        """Test handling of invalid thread counts."""
        test_files = [str(tmp_path / "file.txt")]
        
        with patch('subprocess.run', return_value=MagicMock(returncode=0)):
            # Test negative threads (should default to 1)
            results = execute_gzip_local(test_files, num_threads=-1)
            assert results['compressed'] == 1
            
            # Test zero threads (should auto-detect)
            with patch('multiprocessing.cpu_count', return_value=4):
                results = execute_gzip_local(test_files, num_threads=0)
                assert results['compressed'] == 1
    
    def test_execute_gzip_local_empty_list(self, tmp_path):
        """Test execution with empty file list."""
        results = execute_gzip_local([], num_threads=2)
        
        assert results['total'] == 0
        assert results['compressed'] == 0
        assert results['skipped'] == 0
        assert results['errors'] == 0
        assert len(results['error_files']) == 0
    
    def test_execute_gzip_local_all_compressed(self, tmp_path):
        """Test execution when all files are already compressed."""
        test_files = [
            str(tmp_path / "file1.gz"),
            str(tmp_path / "file2.gz"),
            str(tmp_path / "file3.gz")
        ]
        
        results = execute_gzip_local(test_files, num_threads=2)
        
        assert results['total'] == 3
        assert results['compressed'] == 0
        assert results['skipped'] == 3
        assert results['errors'] == 0
